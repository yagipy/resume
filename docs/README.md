このページは @yagipy の職務経歴を紹介するページです。  
最終更新日: 2022/10/16

## 目次
- 基本情報
- 自己紹介
- 興味
- 職務経歴
  - からくり株式会社 (2019年4月 ~ 在職中)
  - 株式会社taliki (2018年6月 ~ 2019年3月)
  - 株式会社Hatty&Co. (2018年6月 ~ 2018年10月)
- 個人の活動
  - 登壇
  - OSS
  - OSS以外の個人プロジェクト
  - コミュニティ
- 各種リンク

## 基本情報
<table>
  <tr>
    <td>氏名</td>
    <td>八木橋 拓之</td>
  </tr>
  <tr>
    <td>氏名(フリガナ)</td>
    <td>ヤギハシ ヒロユキ</td>
  </tr>
  <tr>
    <td>生年月日</td>
    <td>1998/10/19</td>
  </tr>
  <tr>
    <td>性別</td>
    <td>男</td>
  </tr>
  <tr>
    <td>連絡先</td>
    <td>yo@yagipy.me</td>
  </tr>
</table>

## 自己紹介
八木橋拓之(Hiroyuki YAGIHASHI)です。  
バックエンドエンジニアとして、主にGo/Node.jsを使用したAPIサーバーやライブラリの開発、AWSを用いたインフラ構築を得意としています。  
Reactを使用したWebクライアントの開発、Go/Node.jsの他にRailsを用いたAPIサーバー開発、Androidアプリ開発も実務経験があります。  
直近の業務内容は、見積作成、設計、ベースコードの作成、会社単位で導入事例のない技術の検証と実装を行いつつ、他メンバーのサポートをするというのがメインになります。  
サポートは主にレビューやペアプロ等を通して、設計意図の共有やメンバーが設計に沿った実装を行えるようにしています。  
上記をWebフロントとバックエンド両方とも行っていましたが、2022/03くらいからWebフロントは全体のレビューをするのみになり、バックエンドを中心に行っています。

## 興味
より多くのユーザーや開発者が使用しているサービスやライブラリを書くことに興味があります。  
多くのユーザーが使用している際に起きる技術的な問題は情報が少なく、よりチャレンジングな問題に取り組める可能性が高いと考えています。  
担当領域の広さに比例してやる気が高まる傾向があります。  
幅広い領域を担当することで、より全体最適な意思決定を行える可能性が高まると考えています。  
新しい技術を触ることが好きです。  
新しい技術を使用することによって、今までは極めて大変だった実装が簡単に実装できることや開発者体験が良くなることが多く、そこに楽しみを感じています。

現在興味のある技術領域は下記になります。
- 分散システム
- コンパイラ(主にメモリ管理)
- Go
- Rust
- Web Assembly
- Web標準

## 職務経歴
### からくり株式会社 (2019年4月 ~ 在職中)
2019年4月に新卒入社。  
テックリード(Webフロントエンド/バックエンド)、教育グループリーダー、ソフトウェアエンジニアを担当しています。

#### テックリードとして (2021年4月 ~ 在職中)
Webフロントエンド/バックエンドに関する見積作成や設計、技術選定、レビュー、ドキュメンテーションを行いました。  
ただ、テックリード業のための工数が毎月あるわけではなく、必要なタイミングで(新規開発立ち上げの際や新しい技術を検証/導入する際など)工数をもらって行っています。  
主な実績は**ソフトウェアエンジニアとして**という項目内の各プロジェクトごとにある**利用技術や技術選定に関する思考と行動**の項目に書いています。

#### 教育グループリーダーとして (2020年9月 ~ 在職中)
教育グループでは、会社レベルでの教育に関する施策の立案や実行を担当しました。(メンバー数最大4名)  
エンジニア評価制度に関しても作成しました。  
施策の立案や実行の過程で、「学習する組織」や「リファクタリング•ウェットウェア」、「成人発達理論による能力の成長」という本を読み、体系的な能力開発に関する知識を得ることができました。  
主に行った施策は下記になります。

- KGI/KPIの立案・作成・運用
- エンジニア評価制度(コンピテンシーマトリクス)の立案・作成・運用
- エンジニアメンターシップ制度の立案・作成・実施・運用
- 研修制度のプラッシュアップ
- テックリードによる塾形式の勉強会の立案・実施
- ライブラリ/設計比較検討会の立案・実施

#### ソフトウェアエンジニアとして (2019年4月 ~ 在職中)
プロジェクトは抜粋しています。  
各プロジェクトの項目は**プロジェクト概要と担当領域**、**役割**、**担当工程**、**主な使用技術**、**主な担当業務**で構成されていますが、
リードエンジニアを担当したプロジェクトのみ**利用技術や技術選定に関する思考と行動**を追加しています。  

プロジェクトの網羅性は下記ブログ記事の方が高いですが、このページの方が各プロジェクトをより詳細に書いています。  
[2021年の詳細](https://blog.yagipy.me/2021-in-review)  
[2020年の詳細](https://blog.yagipy.me/2020-in-review)

### オンライン診療アプリ
<table>
  <tr>
    <td>参画期間</td>
    <td>2021/11~現在</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>要件定義、設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      Webフロントエンド/バックエンドのリードエンジニア<br />
      Webフロントエンド/バックエンドのプロジェクトマネジメント(メンバー数最大6名)
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      フロントエンド: TypeScript、React、vite、Chakra UI<br />
      バックエンド: Go、gqlgen、ent<br />
      インフラ: AWS、ECS、Fargate、SNS、SES、Aurora(MySQL互換)、CloudFront、Route53、ALB<br />
      その他: GitHub Actions、GMOPayment、Twilio、OMRON connect Cloud
    </td>
  </tr>
</table>

<details><summary>プロジェクト概要と担当領域</summary>

オンライン診療や医師とのチャットを行うことができるアプリです。  
患者用のWebアプリと医療従事者用のWebアプリ、システム管理者用のWebアプリ、各Webアプリとネイティブアプリに提供するAPIサーバー、インフラ構築を担当しました。
</details>

<details><summary>主な担当業務</summary>

- 設計(DB設計、API設計、技術選定)
- 外部APIとのフロー構築
- gqlgen、entを使用したベースコードの構築
- vite、chakra UI、graphql-code-generatorを使用したベースコードの構築
- GraphQL subscription、redis pub/sub、goroutineを使用したリアルタイムチャット機能の検証及び実装
- Twilioを使用したビデオ通話機能の実装(サーバー側)
- GMOPaymentを使用した定期課金機能
- お客さんとのMTG
  - 技術的な部分に関しての質問回答
- 工数見積
- サーバーサイドのスケジュール/進捗管理
- 品質管理(レビュー、ペアプロ)
- 業務委託面談
- graphql-code-generatorを使用したAPI呼び出し処理及び型の自動生成
</details>

<details><summary>利用技術や技術選定に関する思考と行動</summary>

大きく3つのチャレンジを行いました。
- Goの全面的な導入
- GraphQLによるスキーマ駆動開発の導入
- Project-based monorepoの導入

---

Goの全面的な導入の際に考えたことを書きます。  
工事現場での無傷事故報告アプリで部分的なGoの導入を行い、Rubyを使用していた際の問題が解決され、かつGoを導入することのメリットを確認できました。
今回のプロジェクトは大規模だったこともあり、全面的に導入することで、Goのメリットをより享受できると考えました。  
ですが、全面的にGoを導入する際の懸念事項として、プロジェクト参加者に学習コストが発生することです。  
まずは導入の背景や学習コストが発生することをメンバーに伝え、合意形成を行いました。  
その後、学習コストを最小限にするために、下記を行いました。
- プロジェクト参加時に必要となるスキルセットを明確にしました
- 上記スキルセットを習得するためのタスク一覧及び教材一覧を作成しました
- 勉強会を企画し、その勉強会の中で上記タスクや教材を進めるようにしました
  - 一定期間内で毎週行いました

上記によって、プロジェクトが開始する前にロジェクト参加時に必要となるスキルセットを一部満たすことができました。(工数の関係で完全に満たすことはできませんでした)

---

GraphQLによるスキーマ駆動開発を導入した際に考えたことを書きます。
GraphQLによるスキーマ駆動開発を導入することによって、工事現場での無傷事故報告アプリで発生した下記問題の解決を試みました。
- レスポンスを過度に共通化したことによる無駄なプロパティの発生

問題についての補足ですが、工事現場での無傷事故報告アプリでは大きく2つの方針でレスポンスを決めていました。
1.原則、レスポンスは対象entityの全てのプロパティを返す
- セキュリティ上問題がある場合等は除く
  2.子のentityが必要な場合は、リクエストで指定する
- [Stripeのexpand](https://stripe.com/docs/expand)のような仕組み
- 1に従い、子のentityは全てのプロパティを返す

上記の方針は、画面の表示要素を変えるたびにAPI側のコードを修正しなくても良いようにするために決めたものでした。
ただ、クライアント側の開発者から特定のプロパティのみを返すようにして欲しい、という要望がありました。

画面の表示要素を変えるたびにAPI側のコードを修正しなくても良いようにしつつ、特定のプロパティのみを返すようにするためには、クライアント側でプロパティを指定できるようにすることが必要だと判断しました。

クライアント側でプロパティを指定できるようにする方法として、2つの方法が考えられました。
- GraphQLを導入する
- RESTに[Stripeのexpand](https://stripe.com/docs/expand)と[Google CloudのAPI設計ガイドで紹介されているfields](https://cloud.google.com/apis/design/design_patterns?hl=ja#partial_response)のような仕組みを導入する

下記の理由からGraphQLを導入することにしました。
- RESTはexpandやfieldsの仕組みを実装する必要があるが、GraphQLはライブラリ側で実装されているため、実装コストが低く抑えられる
- GraphQLは採用実績があり(宿泊者管理サービス)、問題が解決されることが明らかであった

---

Project-based monorepoの導入の際に考えたことを書きます。
こちらはプロジェクト立ち上げ初期からではなく、途中から導入しました。
初期はAPIサーバー、Webクライアント、GraphQLスキーマの3つリポジトリに分け、APIサーバーとWebクライアントでGraphQLスキーマのリポジトリをsubmoduleとして参照していました。
この構成で1ヶ月程度運用してみたところ、下記の問題が発生しました。
- GraphQLスキーマの変更を行うと、APIサーバーとWebクライアントの2つのリポジトリで変更を取り込む必要がある
  - プロジェクトの新規開発フェーズでは、GraphQLスキーマの変更が頻繁に発生するため、この作業が大きなコストになっていました
- entの機能で自動生成しているGraphQLスキーマが最新かどうか担保できない
  - GraphQLスキーマをマージする際は、毎回entで変更が入っていないかを確認する必要がありました
- 生成コードとスキーマの整合性が取りづらい
  - gqlgenのgenerateが失敗しているのに気づかず、GraphQLスキーマをマージしてしまうことが何度かありました
- ソースコードとPRの管理が煩雑

上記の問題を解決するためにAPIサーバー、Webクライアント、GraphQLスキーマの3リポジトリを1つのリポジトリに統合しました。
かつ、GitHub Actionsでgenerateのチェックを行うようにし、generateされていなかった場合はマージをブロックするようにしました。
このようにしたことで、問題が下記のように解決されました。
- GraphQLスキーマ変更時の作業コストが大幅に削減された
- entの機能で自動生成しているGraphQLスキーマが最新かどうか担保できるようになった
- 生成コードとスキーマの整合性をCIによって自動で担保できるようになった
- ソースコードとPRの管理が容易になった
</details>

### 工事現場での無傷事故報告アプリ
<table>
  <tr>
    <td>参画期間</td>
    <td>2021/06~現在</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>要件定義、設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      Webフロントエンド/バックエンドのリードエンジニア<br />
      Webフロントエンド/バックエンドのプロジェクトマネジメント(メンバー数最大5名)
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      フロントエンド: TypeScript、React、Next.js、Recoil、TailwindCSS<br />
      バックエンド: gRPC、Go、grpc-gateway、Ruby、guard<br />
      インフラ: AWS、ECS、Fargate、SNS、Aurora(MySQL互換)、CloudFront、Route53、ALB<br />
      その他: GitHub Actions
    </td>
  </tr>
</table>

<details>

#### プロジェクト概要と担当領域
工事現場で無傷事故(ヒヤリハット)が発生した際に報告を行うアプリです。  
報告された内容を確認する管理者用のWeb画面、ネイティブアプリと管理者用Web画面に提供するAPI開発を担当しました。  

#### 主な担当業務
- 設計(DB設計、API設計、技術選定)
- grpc-gatewayを使用したGoサーバーのベースコード作成
- gRPCを使用したRubyサーバーのベースコード作成
- Next.jsを使用したWebクライアントのベースコード作成
- ECS on Fargateでのインフラ構築
- GitHub Actionsを使用した自動デプロイフローの構築
- guardを使用したRubyサーバーのオートリロード
- スケジュール、進捗管理
- 品質管理(レビュー、ペアプロ)
- 業務委託面談

#### 利用技術や技術選定に関する思考と行動
大きく3つのチャレンジを行いました。
- Goの部分的な導入
- gRPCを使用したスキーマ駆動開発の導入
- ECS on Fargateの導入

---

Goの部分的な導入の際に考えたことについて書きます。  
今まで会社がメインで使用していたサーバーサイドの言語はRubyでしたが、この案件で初めてGoを導入しました。  
この意思決定には、Rubyを辞めたい理由とGoを導入したい理由が関係しています。  
まず、Rubyを辞めたい理由ですが、下記になります。
- 動的型付け言語であり、実行しないとエラーの検出が難しい
- 実行速度が遅い
  - 大手ハウスメーカー顧客管理サービスで問題になっていました
- コミュニティが衰退してきていると感じる
  - [TIOBE index](https://www.tiobe.com/tiobe-index/ruby)や[State of the Octoverse](https://octoverse.github.com)等の情報から衰退していると判断しました
  - 技術的な部分ではないですし、多くの人が使っているから良いという訳ではないものの、OSSにおいてコミュニティは重要だと考えています
    - 特にRuby/Ruby on Railsは日本のコミュニティが盛んで、そこにとても大きな価値があると考えているため、コミュニティの衰退は致命的だと思っています

上記理由から、採用する言語は実行速度が早い静的型付け言語で、かつコミュニティが盛んである必要があり、いくつか候補がある中からGoを選択しました。(Goの他にKotlinとTypeScriptを検討しました)
Goを選択した理由としては下記になります。
- 静的型付け言語であり、コンパイル時にエラーを検出できる
- 実行速度が早い
- コミュニティが盛んである
- 言語仕様がシンプルであり、動的型付け言語を扱っていた人でも比較的容易に習得できる
  - Rubyを使っている人が多いのと、大規模なアプリになる可能性が高くプロジェクトに参加する人数が多くなることを考えると、習得難易度は重要でした
- 依存先を比較的少なくできる
  - 大手メガネメーカー店舗向けサービスで依存関係の更新を行う際に、依存先の数が多く大変で、かつ一部は更新の際にエラーが発生し古いバージョンで固定した経験がありました
  - そのため、依存先を少なくできることは魅力的でした

ただ、社内でGoを書ける人が少なかったので、アプリケーションレイヤをマイクロサービス化し、部分的かつ段階的にGoを導入しました。  
具体的にはゲートウェイサーバーはGo、他のサーバーは書けるメンバーが多く社内に知見がたまっているという点でRubyを採用しました。
サーバー間の通信はgRPCを使用しました。
なぜサーバー間通信にgRPCを使用しているかは後述しています。

---

次に、gRPCを使用したスキーマ駆動開発の導入の際に考えたことについて書きます。  
APIのインターフェースはフロントエンドとバックエンドの間で共通の認識を持つ必要があります。  
今までのプロジェクトではAPIのインターフェースはドキュメントか口頭によって共有されていました。  
しかし、下記のような問題が発生していました。  
- ドキュメント
  - 必要な情報が足りない等の不備が発生する可能性がある
  - APIの数が多くなると管理が難しくなり、実装とドキュメントの内容が乖離してしまう
  - 人によって書き方にばらつきがあり、認識を合わせるのに時間がかかる
- 口頭
  - 共有された内容を後から参照できない

上記の問題を解決するために、gRPCを使用したスキーマ駆動開発を導入しました。  
スキーマ駆動開発を導入したことによって、各クライアントとの意思疎通が容易になり、ドキュメンテーションにかかる時間も削減できました。  
かつ、型不一致によるエラーも事前に検知することができるようになりました。  
gRPCではなくOpenAPIを使用することも考えましたが、下記のような理由からgRPCを採用しました。
- ゲートウェイサーバーと他のサーバー間の通信はgRPCを使用しており、インターフェース定義言語を統一したいため
  - なぜサーバー間通信にgRPCを使用しているかは下記2つが理由になります
    - プライベートなAPIなので、標準的なHTTP技術のみで叩ける必要がないため
    - HTTPのことを考えて、URLパスやHTTPメソッド等を決める必要がないため
    - [こちらの記事](https://cloud.google.com/blog/ja/products/api-management/understanding-grpc-openapi-and-rest-and-when-to-use-them)を参考にして選定を行いました
- grpc-gatewayを使用することで、各クライアントにREST APIを提供することが容易に可能だったため  
  - このことによって、gRPCを導入した影響を最小限にすることができました

---

最後に、ECS on Fargateの導入をした際に考えたことについて書きます。
ECS on Fargateは、サーバーレスかつコンテナ化を実現するために導入を行いましたので、ここではなぜサーバーレスかつコンテナ化を実現したかったのかについて書きます。
今まではAWS EC2にAnsibleでプロビジョニングする形でしたが、下記のような問題がありました。
- 初回と2回目以降の処理をそれぞれ記述しなければならない
- 開発環境とSTG/PRD環境でそれぞれ実行環境が違う
  - 実行環境が異なるため、開発環境で再現しない不具合が発生しやすい
  - Ansible自体はVagrantで仮想環境を立てて動作確認をしていたが、Ansibleの動作確認のために仮想環境を立てるのはコストに見合わないと考えていました
    - 実際にその上でアプリを動かすと同じ実行環境で実行できますが、計算リソース的に無駄が多いと考えていました
- EC2関連の管理作業が後回しにされていた

上記の問題を、サーバーレスかつコンテナ化をすることで解決したいと考えました。  
サーバーレスかつコンテナ化することで、上記問題の解決に加えて、インフラ管理コストの大幅な軽減、AutoScalingの容易化及び高速化を実現できました。  
なお、コントロールプレーンはEKSでも可能でしたが、EKSはECSに比べて学習コストおよび運用コストが高いと考えており、今後何かしらの課題が発生した際はEKSにする可能性はあるが、問題が発生するまではECSで良いと判断しました。

</details>

### 認証認可基盤システム
<table>
  <tr>
    <td>参画期間</td>
    <td>2020/10~現在</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>要件定義、設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      Webフロントエンド/バックエンドのリードエンジニア<br />
      Webフロントエンド/バックエンドのプロジェクトマネジメント(メンバー数最大2名)
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      フロントエンド: TypeScript、React、Next.js、Recoil、TailwindCSS<br />
      バックエンド: JavaScript、TypeScript、prisma、ldapjs、samba-client、sequelize、Serverless Framework<br />
      インフラ: AWS、Lambda、API Gateway、EC2、RDS、RDS Proxy<br />
      その他: GitHub Actions
    </td>
  </tr>
</table>

<details>

#### プロジェクト概要と担当領域
社員が使うアプリの認証が各アプリのサーバーで実装しており、情報が散在していた。  
その情報を集約することを目的に認証認可基盤を作成。  
Web管理画面とAPI開発を担当。

#### 主な担当業務
- 技術選定
- Serverless Frameworkを使用したベースコードの作成
- Next.js、Recoil、TailwindCSSを使用したベースコードの作成
- LDAP認証の実装
- Sambaへのファイルアップロード実装
  - Lambda上でAmazonLinux2のネイティブバイナリパッケージ(samba-client)を使用することで実現
- CSVをstreamにして読み込みつつDBにインサートするバッチ処理の実装
- 各種APIの実装
- スケジュール、進捗管理
- 品質管理(レビュー、ペアプロ)

#### 利用技術や技術選定に関する思考と行動
インフラ構成や言語については、お客さんの方から要望があったため、要望に答える形で実装しました。  
APIはAPI Gateway + Lambdaの構成になっています。  
DBはMySQL互換のRDSを使用しています。(コネクション管理はRDS Proxyを使用しています。)  
管理画面は"アクセスをプライベートネットワークに閉じたい"という要件があったため、会社でよく使っていたS3の静的Webサイトホスティングを使用して、プライベートIPのみを設定できないか調査を行いました。  
上記を調査しているタイミングでAWS PrivateLink for Amazon S3の一般提供が開始され、これで可能になると考えていたのですが、静的WebサイトホスティングはPrivateLinkに対応していないことがわかりました。  
最終的にはEC2でホスティング(Nginxを使用しています)を行いました。

最初はお客さんの方でもAWS Web コンソールでインフラを変更する可能性があるということだったので、API全体の管理ライブラリは導入せず、デプロイや環境変数の切り替えはシェルスクリプトを独自に組んで使用していました。  
Serverless FrameworkやAWS SAMはインフラの設定に意図しない変更が出てしまうことを懸念して導入しないという判断をしました。  
ですが、取引会社さんの方で変更する部分が大体分かってきたというのもあり、取引会社さんと交渉し、大きな機能追加開発が入るタイミングでServerless Frameworkを導入しました。  
導入によって基盤全体の見通しが良くなっただけではなく、属人化の排除、インフラ設定の共通化、テスト環境と開発環境での実行が容易に出来るようになりました。  
なお、上記のタイミングでJavaScriptからTypeScriptへの移行も行い、より安全に開発を行えるようになりました。

TODO: 更新する
Webアプリは新しくRecoilを導入しました。

</details>

### 宿泊者管理サービス
<table>
  <tr>
    <td>参画期間</td>
    <td>2020/6~2020/9</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>要件定義、設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      Webフロントエンド/バックエンドのリードエンジニア
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      フロントエンド: TypeScript、React、Next.js、Redux、Redux Saga、Apollo Client<br />
      バックエンド: Ruby、Ruby on Rails、graphql-ruby、capistrano<br />
      インフラ: Terraform、AWS、EC2、RDS、ALB、S3、CloudFront<br />
      その他: GitHub Actions
    </td>
  </tr>
</table>

<details>

#### プロジェクト概要と担当領域
宿泊者の入退室を管理したり、管理者とチャットやビデオ通話を行うことが出来るアプリ。
管理者が使用するWebアプリとAPIサーバーを担当。

#### 主な担当業務
- graphql-rubyを使用したGraphQLサーバーのベースコード作成
  - 管理者のCRUDとログイン機能の実装
- Next.jsを使用したWebアプリのベースコード作成
  - 管理者のCRUDとログイン機能の実装
- Terraformを使用したインフラ構築

#### 利用技術や技術選定に関する思考と行動
大きく3つのチャレンジを行いました。
- GraphQLの導入
- Next.jsの導入
- Terraformを使用したIaCの導入

GraphQLの導入ですが、大手ハウスメーカー顧客管理サービスで発生していた問題を解決することを試みました。
主に問題となっていたのは下記の3つです。
- 画面の表示要素を変えるたびに、API側のコードを修正する必要がある
- 1画面で複数のAPIを叩いており、画面描画に遅れが出ていた/フロント側で取得した値を管理しづらい
- APIが様々な画面で叩かれているため、どのレスポンスの値がどこで使われているか把握しづらく、レスポンスの値を削除しにくい

解決策として、下記の2つを候補として考えました。
- RESTに[Stripeのexpand](https://stripe.com/docs/expand)や[Google CloudのAPI設計ガイドで紹介されているfields](https://cloud.google.com/apis/design/design_patterns?hl=ja#partial_response)というリクエストパラメータを追加し、レスポンスをリクエストパラメータに応じて変更するようにする
- GraphQLを使用する

どちらでも解決可能でしたが、下記の理由によりGraphQLを採用しました。
- アプリの比較的小規模であり、挑戦的な技術選定が可能であるため
- 今後社内でGraphQLを導入する可能性を考慮し、小規模なアプリで使用することで影響範囲を最小限にしつつ社内にGraphQLの知見をためることができるため
- コアロジックを分離しておけば低コストでRESTへの切り替えが可能であると判断したため

その結果、問題が解決されただけではなく、今後の開発においてもGraphQLという選択肢を取ることが以前より容易になり、会社全体としても問題解決の幅が広がったと考えています。

TODO: Next.jsの導入の思考を書く  
TODO: Terraformを使用したIaCの導入の思考を書く

</details>

### 大手ハウスメーカー顧客管理サービス
<table>
  <tr>
    <td>参画期間</td>
    <td>2020/2~2020/6</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>要件定義、設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      Webフロントエンド/バックエンドエンジニア
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      フロントエンド: TypeScript、React、crate-react-app、Redux、react-pdf、react-table<br />
      バックエンド: Ruby、Ruby on Rails、graphql-ruby、capistrano<br />
      その他: GitHub Actions、Circle CI、Ansible
    </td>
  </tr>
</table>

<details>

#### プロジェクト概要と担当領域
ハウスメーカーと住宅を購入した顧客がコミュニケーションを取るアプリ。
顧客が使用するWebアプリと大手ハウスメーカーが使用するWebアプリ、それぞれのWeb画面に提供するAPIの開発を担当。

#### 主な担当業務  
- 複数画面のAPI繋ぎ込み
- react-pdfを使用したWebフロントでのPDF生成
- 複数ファイルのアップロード機能
- react-tableを使用した週次カレンダー機能の作成  
- 各区分ごとにソートを行う処理
- パフォーマンスの最適化

</details>

### 大手メガネメーカー店舗向けサービス
<table>
  <tr>
    <td>参画期間</td>
    <td>2019/6~2020/9</td>
  </tr>
  <tr>
    <td>担当工程</td>
    <td>設計、実装、テスト</td>
  </tr>
  <tr>
    <td>役割</td>
    <td>
      バックエンドエンジニア
      Androidエンジニア
    </td>
  </tr>
  <tr>
    <td>主な使用技術</td>
    <td>
      Android: Java、Android、Dagger、RxJava<br />
      バックエンド: Ruby、Ruby on Rails、graphql-ruby、capistrano<br />
      その他: GitHub Actions、Circle CI、Ansible
    </td>
  </tr>
</table>

<details>

#### プロジェクト概要と担当領域
メガネの販促アプリ。購入後は保険証をアプリで管理することが出来る。
実際にメガネを購入するユーザーが使用するAndroidアプリと、ネイティブアプリに提供するAPIサーバーを作成。

#### 主な担当業務
- バックエンド
  - 友達招待機能
  - Railsアップグレード(4.2->5.2)
  - GMOPaymentを使用した決済機能のベース実装
- Android
  - 楽天Pay、LINEPayの決済機能
  - クレジットカードのカメラ読み取り機能

</details>

### 株式会社taliki (2018年6月 ~ 2019年3月)

インターンとして参画、インフラエンジニアを担当しました。

<details>

#### プロジェクト概要と担当領域
SNS上で応援を集められるサービス[ちあちあ](https://prtimes.jp/main/html/rd/p/000000003.000036295.html)のインフラ構築を担当しました。

#### 役割
- インフラエンジニア

#### 担当工程
- 実装(インフラ構築)

#### 主な使用技術
- AWS
  - EC2
  - ELB
  - Route53
- Nginx
- PostgreSQL

#### 主な担当業務
- EC2上にDjango実行環境の構築
  - DB: PostgreSQL
  - Webサーバー: Nginx
- お名前.comからRoute53へのドメイン移管
- お名前.comからRoute53へDNSを変更
</details>

### 株式会社Hatty&Co. (2018年6月 ~ 2018年10月)

1人目のエンジニアとして参画、CTOを担当しました。  

<details>

#### プロジェクト概要と担当領域
大学のサークルを経由してチャットできるマッチングアプリ、"Camel"の構築を担当しました。  
資金調達や開発が難航したため、リリースには至りませんでした。

#### 役割
- エンジニア
- CTO

#### 担当工程
- 要件定義、設計、実装、テスト

#### 主な使用技術
- Ruby on Rails
- AWS
  - EC2
  - ELB
  - Route53
  - RDS
- Nginx
- MySQL

#### 主な担当業務
- 機能一覧の作成
- API設計
- DB設計
- ユーザー、グループ、チャットルームのCRUD等、主要な機能を実装

</details>

## 個人の活動
### 登壇
- What is Soft Memory Limit?@[Go 1.19 Release Party](https://gocon.connpass.com/event/253355)
  - [登壇資料](https://speakerdeck.com/yagipy/what-is-soft-memory-limit)
  - [ブログ記事](https://blog.yagipy.me/go119party)
- Building markdown editor using Rust’s parser@[JS Conf JP 2021](https://jsconf.jp/2021)
  - [登壇資料](https://speakerdeck.com/yagipy/building-markdown-editor-using-rusts-parser)
  - [ブログ記事](https://blog.yagipy.me/jsconfjp-2021)
- OSSに貢献した話と社内での取り組みについて@[技育祭2021](https://talent.supporterz.jp/geeksai/2021)
  - [登壇資料](https://speakerdeck.com/yagipy/ossnigong-xian-sitahua-toshe-nei-tefalsequ-rizu-minituite)
  - [ブログ記事](https://blog.yagipy.me/geeksai-lt)
- 簡易的な推薦機能を実装する@社内LT
  - [登壇資料](https://speakerdeck.com/yagipy/jian-yi-de-natui-jian-ji-neng-woshi-zhuang-suru)
- Git/GitHub oneliner command@社内LT
  - [登壇資料](https://speakerdeck.com/yagipy/github-oneliner-command)

### OSS
Owner - 私自身が作成し運用しているOSSになります  
Maintainer - リポジトリに対するWrite権限を持っているOSSになります  
Contributor - コントリビュートしたことのあるOSSになります(ここでは私自身が作成したPRがマージされたことのあるOSSに限定しています)

- Owner - [maintidx](https://github.com/yagipy/maintidx)
  - maintainability indexを計測するために作成した静的解析ツールです 
  - GitHub Starを60以上獲得しています
  - 詳しくは[こちら](https://blog.yagipy.me/analyze-maintainability-index)
- Owner - [chameleon editor](https://cameleon-editor.netlify.app/)
  - HTML、スライド、マインドマップに描画可能なマークダウンエディタです 
  - マークダウンパーサーはRustとwasmを使用しています
  - 詳しくは[こちら](https://blog.yagipy.me/md-editor-with-rust-parser-on-the-web)
- Owner - [blog](https://blog.yagipy.me/)
  - Next.js使用、TailwindCSS使用、PWA対応、AMP対応、OGP画像の自動生成等を行っています
  - 詳しくは[こちら](https://blog.yagipy.me/build-blog)
- Maintainer - [golangci-lint](https://github.com/golangci/golangci-lint)
  - Goの静的解析ツールをまとめて実行してくれるツールです
  - [maintidx](https://github.com/yagipy/maintidx) を追加する実装をしました
- Contributor - [go-gimei](https://github.com/mattn/go-gimei)
  - レースコンディションを回避する実装をしました
- Contributor - [Node.js](https://github.com/nodejs/node)
  - fsPromise.writeFileのdata引数としてasync iteratorsをサポートする実装をしました
  - 詳しくは[こちら](https://blog.yagipy.me/nodejs-writefile-support-async-iterators)
- Contributor - [DroidKaigi conference app 2021](https://github.com/DroidKaigi/conference-app-2021)
  - ダークモードの対応や軽微な修正を行いました

### OSS以外の個人プロジェクト
- [runlive](https://runlive.netlify.app/)
  - 事業化を目指しており、現在ソースコードはプライベートで開発しています 
  - 複数言語が実行可能なプレイグラウンドです
    - 現在はPythonのみサポートしています
  - WebRTCを使用したリアルタイムに変更が反映されるコラボレーション機能、wasmを使用したWeb完結でのソースコード実行機能、ソースコードのシェア機能があります 
  - 今後はデプロイ機能やアカウント管理機能も追加する予定です

### コミュニティ
- トレーニー - [SecHack365](https://sechack365.nict.go.jp)
  - [SecHack365](https://sechack365.nict.go.jp)という、セキュリティイノベーター人材育成のためにNICTが主催しているプログラムに参加しています
  - 2022年度のトレーニーとして参加しています
  - RustとLLVMを使用して、プログラミング言語を作成しています
    - 所有権付き参照カウントという、特徴的なメモリ管理機能を実装しています
- Staff - [Go Conference](https://gocon.jp)
  - [2022 Spring](https://gocon.jp/2022spring/) から運営のお手伝いをしています

## 各種リンク
- [GitHub](https://github.com/yagipy)
- [Twitter](https://twitter.com/yagipy_)
- [Blog](https://blog.yagipy.me)
- [SpeakerDeck](https://speakerdeck.com/yagipy)
